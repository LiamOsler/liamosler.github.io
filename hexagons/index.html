<!DOCTYPE html>
<html>
<head>
    <title>Bestagon</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">

    <link rel="stylesheet" href="https://cdn.datatables.net/1.13.3/css/dataTables.bootstrap5.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.3/jquery.min.js"></script>


    <script type="importmap">
        {
            "imports": {
                "three": "./js/three.module.js",
                "GLTFLoader": "./js/GLTFLoader.js"
            }
        }
    </script>

    <style>
        body{
            overflow: hidden;
        }
        #three-background{
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

    </style>

</head>

<body>
    <div id = "three-background">
        <div id = "three-area"></div>
    </div>
    <script type= "module">
        import { OrbitControls } from './js/OrbitControls.js';
        import { GLTFLoader } from './js/GLTFLoader.js';
        import * as THREE from './js/three.module.js';

        const threeBackground = document.getElementById('three-background');
        const threeArea = document.getElementById('three-area');

        let scene, camera, renderer, controls, clock;
        let axesHelper;
        let spotLightTop, spotLightBottom, ambientLight;

        clock = new THREE.Clock();
        let deltaTime = 0;
        let totalTime = 0;

        const loader = new GLTFLoader();
        loader.load(
            '/gltf/hex.glb',
            function ( gltf ) {
                const hex = gltf.scene;
                hex.traverse(function(element) {
                    console.log(element);
                    element.material = materials.unselected;
                })
                scene.add( hex );
            },
            function ( xhr ) {
                console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
            },
            function ( error ) {
                console.log( 'An error occured' );
            }
        );

        function LatLonToXYZ(coords, radius){
            let lon   = coords[0];
            let lat   = coords[1];
            let phi   = ( 90 - lat ) * ( Math.PI / 180 );
            let theta = ( lon + 180 ) * ( Math.PI / 180 );

            let x = -( radius * Math.sin( phi ) * Math.cos( theta ));
            let z =  ( radius * Math.sin( phi ) * Math.sin( theta ));
            let y =  ( radius * Math.cos( phi ));

            return new THREE.Vector3( x , y , z);
        }
        
        const lineMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff } );
        const materials = {
            land:       new THREE.MeshBasicMaterial( { color: 0xffffff } ),
            water:      new THREE.MeshBasicMaterial( { color: 0xdddddd } ),
            habitation: new THREE.MeshBasicMaterial( { color: 0xffff00 } ),
            place:      new THREE.MeshBasicMaterial( { color: 0xffff97 } ),
            selected:   new THREE.MeshBasicMaterial( { color: 0xaaaaaa } ),
            unselected: new THREE.MeshBasicMaterial( { color: 0x333333 } ),

        }

        function drawPoint(coordinates, population, type){
            let position = LatLonToXYZ( coordinates, 30 );
            const pointGeometry = new THREE.SphereGeometry( 0.001 * Math.cbrt(population), 32, 16 );
            const point = new THREE.Mesh( pointGeometry, materials[type] );
            point.position.set(position.x, position.y, position.z);
            scene.add(point);
        }

        function drawLine(coordinates, type){

            const linePoints = [];
            for(let item of coordinates){
                let position = LatLonToXYZ( item, 30 );
                linePoints.push( position );
            }
            const lineGeometry = new THREE.BufferGeometry().setFromPoints( linePoints );
            const line = new THREE.Line( lineGeometry, materials[type] );
            scene.add(line);
        }

        function drawPolygon(polygon, type){
            for(let geometry of polygon.geometry.coordinates){
                drawLine(geometry, type);
            }
        }

        function drawMultiPolygon(MultiPolygon, type){
            for(let polygon of MultiPolygon.geometry.coordinates){
                for(let geometry of polygon){
                    drawLine(geometry, type);
                }
            }
        }

        function drawGEOJSONPoints(pointData, type){
            for(let point of pointData.features){
                drawPoint( [point.properties.LONGITUDE, point.properties.LATITUDE], point.properties.POP_MAX, type );
            }
        }

        function drawGEOJSONPolygons(polyData, type){
            for(let polygon of polyData.features){
                if(polygon.geometry.type == "Polygon"){
                    drawPolygon( polygon, type );
                }
                if(polygon.geometry.type == "MultiPolygon"){
                    drawMultiPolygon( polygon, type );
                }
            }
        }

        function init(){
            threeBackground.style.backgroundImage = `radial-gradient(circle, rgba(255,255,150,1) 0%, rgba(0,0,0,1) 90%)`;

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 4000 );

            renderer = new THREE.WebGLRenderer({ alpha: true });
            renderer.setClearColor( 0x000000, 0 );
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );
            
            spotLightTop = new THREE.SpotLight( 0xffffff );
            spotLightTop.position.set( 0, 0, 1000 );
            scene.add( spotLightTop );

            ambientLight = new THREE.AmbientLight( 0xffffff );
            scene.add( ambientLight );

            const geometry = new THREE.SphereGeometry(29.9, 32, 16 );
            const material = new THREE.MeshBasicMaterial( { color: 0x222222 } );
            const backgroundSphere = new THREE.Mesh( geometry, material );
            backgroundSphere.name = "backgroundSphere";
            scene.add( backgroundSphere );

            camera.position.x = 30;
            camera.position.y = 30;
            camera.position.z = 30;

            axesHelper = new THREE.AxesHelper( 50 );
            // scene.add( axesHelper );

            controls = new OrbitControls( camera, renderer.domElement );
            controls.dampingFactor = 10;
            controls.enablePan = false;
            controls.minDistance = 35;

        }

        async function loadData(){
            await fetch('./geojson/places.json', { cache: "force-cache" }).then(response => {
                    return response.json();
                }).then(data => {
                    drawGEOJSONPoints(data, "place");
                }).catch(err => {
            });

            await fetch('./geojson/land.json', { cache: "force-cache" }).then(response => {
                    return response.json();
                }).then(data => {
                    drawGEOJSONPolygons(data, "land");
                }).catch(err => {
            });

            // await fetch('./geojson/lakes.json', { cache: "force-cache" }).then(response => {
            //         return response.json();
            //     }).then(data => {
            //         drawGEOJSONPolygons(data, "water");
            //     }).catch(err => {
            // });

            // await fetch('./geojson/cities.json', { cache: "force-cache" }).then(response => {
            //         return response.json();
            //     }).then(data => {
            //         drawGEOJSONPolygons(data, "habitation");
            //     }).catch(err => {
            // });
        }

        let selectedList = [];
        
        function animate() {
            requestAnimationFrame( animate );

            raycaster.setFromCamera( pointer, camera );

            // calculate objects intersecting the picking ray
            const intersects = raycaster.intersectObjects( scene.children );
            lastPointer = pointer;

            for ( let i = 0; i < intersects.length; i ++ ) {
                if(intersects[ i ].object.name.includes("hexasphere")){
                    if(mousedown){
                        console.log(mousedownTime.getElapsedTime())
                        console.log(selectedList)
                        console.log(pointer);

                        if( !selectedList.includes(intersects[ i ].object.name) 
                            && mousedownTime.getElapsedTime() > 0.5 
                            && !pressRelease
                            && Math.abs(pointer.y) < .3
                            && Math.abs(pointer.x) < .3
                            ){
                            selectedList.push(intersects[ i ].object.name);
                            intersects[ i ].object.material = materials["selected"];
                            pressRelease = true;
                        }
                        else if (   selectedList.includes(intersects[ i ].object.name) 
                                    && selectedList.indexOf(intersects[ i ].object.name) != selectedList.length-1 
                                    && !pressRelease){
                            intersects[ i ].object.material = materials["unselected"];
                            selectedList.splice(selectedList.indexOf(intersects[ i ].object.name), 1);
                        }

                    }
                }
            }

            renderer.render( scene, camera );
            controls.update();
        }

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        let lastPointer;


        init();
        animate();
        loadData();

        window.addEventListener( 'pointermove', event =>{
            pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
            pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        } );

        window.addEventListener('resize', event => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        let scrollFactor = 1;
        window.addEventListener("wheel", event => {
            let scrollFactor = controls.getDistance() / 10;
            threeBackground.style.backgroundImage = '';
            threeBackground.style.backgroundImage = `radial-gradient(circle, rgba(255,255,150,1) ${0}%, rgba(0,0,0,1) ${90-scrollFactor}%)`;
        });

        let mousedown = false;
        let mousedownTime = new THREE.Clock();
        let pressRelease = false;
        window.addEventListener("mousedown" , event => {
            mousedown = true;
            mousedownTime.start();
            console.log("mouse down")

        });

        window.addEventListener("mouseup" , event => {
            mousedown = false;
            mousedownTime.stop();
            console.log("mouse up")
            pressRelease = false;

        });

    </script>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4" crossorigin="anonymous"></script>

</body>